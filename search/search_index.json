{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Qontrol","text":"<p>qontrol is a quantum optimal control package built on top of dynamiqs. You can define your controls however you would in dynamiqs, specifying only how to update the Hamiltonian at each optimizer step. dynamiqs also has strong native support for batching, which qontrol can leverage e.g. for randomizing over uncertain parameters.</p>"},{"location":"#installation","title":"Installation","text":"<p>For now we support only installing directly from github <pre><code>pip install git+https://github.com/dkweiss31/qontrol\n</code></pre></p> <p>Requires Python 3.10+</p>"},{"location":"#quick-example","title":"Quick example","text":"<p>Optimal control of a Kerr oscillator, with piece-wise constant drives on the I and Q quadratures and optimizing for a <code>Y</code> gate</p> <p><pre><code>import dynamiqs as dq\nimport jax.numpy as jnp\nimport optax\nimport qontrol as ql\n\n# hyper parameters\nn = 5  # system size\nK = -0.2 * 2.0 * jnp.pi  # Kerr nonlinearity\ntime = 40.0  # total simulation time\ndt = 2.0  # control dt\nseed_amplitude = 1e-3  # pulse seed amplitude\nlearning_rate = 1e-4  # learning rate for optimizer\n\n# define model to optimize\na = dq.destroy(5)\nH0 = 0.5 * K * dq.dag(a) @ dq.dag(a) @ a @ a\nH1s = [a + dq.dag(a), 1j * (a - dq.dag(a))]\n\n\ndef H_pwc(drive_params):\n    H = H0\n    for idx, _H1 in enumerate(H1s):\n        H += dq.pwc(tsave, drive_params[idx], _H1)\n    return H\n\ninitial_states = [dq.basis(n, 0), dq.basis(n, 1)]\n# We can track the behavior of observables by passing them to the model. Here we track\n# the state populations\nexp_ops = [dq.basis(n, idx) @ dq.dag(dq.basis(n, idx)) for idx in range(n)]\nntimes = int(time // dt) + 1\ntsave = jnp.linspace(0, time, ntimes)\nmodel = ql.sesolve_model(H_pwc, initial_states, tsave, exp_ops=exp_ops)\n\n# define optimization\nparameters = seed_amplitude * jnp.ones((len(H1s), ntimes - 1))\ntarget_states = [-1j * dq.basis(n, 1), 1j * dq.basis(n, 0)]\ncost = ql.cost.coherent_infidelity(target_states=target_states, target_cost=0.001)\noptimizer = optax.adam(learning_rate=0.0001)\nopt_options = {\"verbose\": False, \"plot\": True, \"plot_period\": 5}\ndq_options = dq.Options(save_states=False, progress_meter=None)\n\n# run optimization\nopt_params = ql.optimize(\n    parameters,\n    cost,\n    model,\n    optimizer=optimizer,\n    opt_options=opt_options,\n    dq_options=dq_options,\n)\n</code></pre> You should see the following output, tracking the cost function values, pulse, pulse fft and expectation  values over the course of the optimization   We initialize the <code>sesolve_model</code> which when called with <code>parameters</code> as input runs <code>sesolve</code> and returns that result as well as the updated Hamiltonian. These are in turn passed to  the cost functions, which tell the optimizer how to update <code>parameters</code>.</p>"},{"location":"#jump-in","title":"Jump in","text":"<p>If this has piqued your interest, please see the example jupyter notebooks that demonstrate different use cases of <code>qontrol</code>, including optimizing gates on a qubit to be robust to frequency variations as well as performing time-optimal control and master-equation optimization. More examples coming soon!</p>"},{"location":"#citation","title":"Citation","text":"<p>If you found this package useful in academic work, please cite</p> <pre><code>@unpublished{qontrol2024,\n  title  = {qontrol: Quantum optimal control based on dynamiqs, diffrax and JAX},\n  author = {Daniel K. Weiss},\n  year   = {2024},\n  url    = {https://github.com/dkweiss31/qontrol}\n}\n</code></pre> <p>Also please consider starring the project on github!</p>"},{"location":"FAQ/","title":"FAQ","text":""},{"location":"FAQ/#how-can-i-incorporate-drive-constraints-as-opposed-to-costs","title":"How can I incorporate drive constraints (as opposed to costs)?","text":"<p>Constraints can be incorporated at the level of the Hamiltonian function:</p> <pre><code>a = dq.destroy(5)\nH0 = dq.dag(a) @ dq.dag(a) @ a @ a\nH1s = [a + dq.dag(a), 1j * (a - dq.dag(a))]\nmax_amp = 2.0 * jnp.pi * 0.01\ntsave = jnp.linspace(0, 40.0, 31)\nparameters = jnp.zeros((len(H1s), len(tsave) - 1))\n\ndef H_pwc(drive_params):\n    H = H0\n    for idx, _H1 in enumerate(H1s):\n        clipped_drive = jnp.clip(\n            drive_params[idx],\n            a_min=-max_amp,\n            a_max=max_amp,\n        )\n        H += dq.pwc(tsave, clipped_drive, _H1)\n    return H\n</code></pre>"},{"location":"FAQ/#how-do-i-initialize-random-initial-pulses","title":"How do I initialize random initial pulses?","text":"<p>This can be done by utilizing existing rng functionality from jax. Lets create a random initial guess for the <code>pwc</code> control above with values between +1 and -1. <pre><code>key = jax.random.PRNGKey(31)\nparameters = 2.0 * jax.random.uniform(key, (len(H1s), len(tsave) - 1)) - 1.0\n</code></pre></p>"},{"location":"FAQ/#how-do-i-monitor-custom-quantities-during-optimization","title":"How do I monitor custom quantities during optimization?","text":"<p>We provide functionality for the user to plot whatever quantities they'd like to monitor during the course of the optimization. Simply define one or multiple functions with the signature <code>plotting_function(ax, expects, model, parameters)</code>, where <code>ax</code> is a <code>matplotlib.pyplot.Axes</code> object that is updated, <code>expects</code> contains the output of <code>dq.SolveResult.expects</code>, <code>model</code> has type <code>ql.Model</code> and <code>parameters</code> are the parameters being optimized. Let's imagine you are batching over multiple different frequency values and want a pulse that is robust to these frequency variations. You want to plot the expectation values of each trajectory, and want separate plots for two different initial states.  <pre><code>n_batch = 21\n\ndef plot_states(ax, expects, model, parameters, which=0,):\n    ax.set_facecolor('none')\n    tsave = model.tsave_function(parameters)\n    for batch_idx in range(n_batch):\n        ax.plot(tsave, np.real(expects[batch_idx, which, 0]))\n    ax.set_xlabel('time [ns]')\n    ax.set_ylabel(f'population in $|1\\\\rangle$ for initial state $|{which}\\\\rangle$')\n    return ax\n\nplotter = ql.custom_plotter(\n    [ql.plot_controls,\n     functools.partial(plot_states, which=0),\n     functools.partial(plot_states, which=1)]\n)\n</code></pre> See this tutorial for this sort of functionality in practice. Note there is no limit to the number of panels you can plot: plots will appear in rows with four plots in each row.</p>"},{"location":"FAQ/#how-do-i-access-the-saved-information","title":"How do I access the saved information?","text":"<p>If a <code>filepath</code> is passed to <code>optimize</code>, the parameters from each epoch are saved along with the individual values of each cost function and the total cost. This data can be extracted via (assuming the data has been saved in the file 'tmp.h5py')</p> <p><pre><code>data_dict, param_dict = ql.extract_info_from_h5('tmp.h5py')\n</code></pre> where <code>data_dict</code> contains the optimized parameters as well as cost function info, and <code>param_dict</code> contains the options passed to <code>optimize</code>.</p>"},{"location":"FAQ/#you-havent-defined-my-favorite-cost-function","title":"You haven't defined my favorite cost function?!","text":"<p>No worries! See the API of <code>ql.custom_cost()</code> as well as <code>ql.custom_control_cost()</code> for examples of how to define custom cost functions.</p>"},{"location":"api/","title":"Python API","text":"<p>The qontrol Python API consists of the function optimize which performs optimal control, and various models that can be optimized including SESolveModel and MESolveModel. There are additionally various utility functions and classes that help to define an optimization routine (cost functions, file input output, options, etc.)</p>"},{"location":"api/#optimization","title":"Optimization","text":""},{"location":"api/#qontrol.optimize.optimize","title":"<code>optimize(parameters: ArrayLike | dict, costs: Cost, model: Model, *, optimizer: GradientTransformation = optax.adam(0.0001, b1=0.99, b2=0.99), plotter: Plotter | None = None, method: Method = Tsit5(), gradient: Gradient | None = None, dq_options: dq.Options = dq.Options(), opt_options: dict | None = None, filepath: str | None = None) -&gt; Array | dict</code>","text":"<p>Perform gradient descent to optimize Hamiltonian parameters.</p> <p>This function takes as input <code>parameters</code> which parametrize a <code>model</code> when called performs time-dynamics simulations using Dynamiqs. How to update <code>parameters</code> is encoded in the list of cost functions <code>costs</code> that contains e.g. infidelity contributions, pulse amplitude penalties, etc.</p> <p>Parameters:</p> <ul> <li> <code>parameters</code>               (<code>ArrayLike | dict</code>)           \u2013            <p>parameters to optimize over that are used to define the Hamiltonian and control times.</p> </li> <li> <code>costs</code>               (<code>Cost</code>)           \u2013            <p>List of cost functions used to perform the optimization.</p> </li> <li> <code>model</code>               (<code>Model</code>)           \u2013            <p>Model that is called at each iteration step.</p> </li> <li> <code>optimizer</code>               (<code>GradientTransformation</code>, default:                   <code>adam(0.0001, b1=0.99, b2=0.99)</code> )           \u2013            <p>optax optimizer to use for gradient descent. Defaults to the Adam optimizer.</p> </li> <li> <code>plotter</code>               (<code>Plotter | None</code>, default:                   <code>None</code> )           \u2013            <p>Plotter for monitoring the optimization.</p> </li> <li> <code>method</code>               (<code>Method</code>, default:                   <code>Tsit5()</code> )           \u2013            <p>Method passed to Dynamiqs.</p> </li> <li> <code>gradient</code>               (<code>Gradient | None</code>, default:                   <code>None</code> )           \u2013            <p>Gradient passed to Dynamiqs.</p> </li> <li> <code>filepath</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Filepath of where to save optimization results.</p> </li> <li> <code>dq_options </code>           \u2013            <p>Options for the Dynamiqs integrator.</p> </li> <li> <code>opt_options</code>               (<code>dict | None</code>, default:                   <code>None</code> )           \u2013            <p>Options for grape optimization.</p> Detailed <code>opt_options</code> API <ul> <li><code>verbose</code> (<code>bool</code>, default: <code>True</code>): If <code>True</code>, the optimizer will     print out the infidelity at each epoch step to track the progress of     the optimization.</li> <li><code>ignore_termination</code> (<code>bool</code>, default: <code>False</code>): Whether to ignore the     various termination conditions</li> <li><code>all_costs</code> (<code>bool</code>, default: <code>True</code>): Whether or not all costs must     be below their targets for early termination of the optimizer. If     <code>False</code>, the optimization terminates if only one cost function is     below the target (typically infidelity).</li> <li><code>epochs</code> (<code>int</code>, default: <code>2000</code>): Number of optimization epochs.</li> <li><code>plot</code> (<code>bool</code>, default: <code>True</code>): Whether to plot the results during     the optimization (for the epochs where results are plotted,     necessarily suffer a time penalty).</li> <li><code>plot_period</code> (<code>int</code>, default: <code>30</code>): If plot is <code>True</code>, plot every     <code>plot_period</code>.</li> <li><code>save_period</code> (<code>int</code>, default: <code>30</code>): If a filepath is provided, save     every <code>save_period</code>.</li> <li><code>xtol</code> (<code>float</code>, default: <code>1e-8</code>): Terminate the optimization if the     parameters are not being updated.</li> <li><code>ftol</code> (<code>float</code>, default: <code>1e-8</code>): Terminate the optimization if the     cost function is not changing above this level.</li> <li><code>gtol</code> (<code>float</code>, default: <code>1e-8</code>): Terminate the optimization if the     norm of the gradient falls below this level.</li> </ul> </li> </ul> <p>Returns:</p> <ul> <li> <code>Array | dict</code>           \u2013            <p>Optimized parameters from the final timestep.</p> </li> </ul>"},{"location":"api/#cost-functions","title":"Cost functions","text":""},{"location":"api/#qontrol.cost.incoherent_infidelity","title":"<code>incoherent_infidelity(target_states: list[QArrayLike], cost_multiplier: float = 1.0, target_cost: float = 0.005) -&gt; IncoherentInfidelity</code>","text":"<p>Instantiate the cost function for calculating infidelity incoherently.</p> <p>This fidelity is defined as $$     F_{\\rm incoherent} = \\sum_{k}|\\langle\\psi_{t}^{k}|\\psi_{i}^{k}(T)\\rangle|^2, $$ where the states at the end of the pulse are \\(|\\psi_{i}^{k}(T)\\rangle\\) and the target states are \\(|\\psi_{t}^{k}\\rangle\\).</p> <p>Parameters:</p> <ul> <li> <code>target_states</code>               (<code>list[QArrayLike]</code>)           \u2013            <p>Shape of QArrays = (s, n, 1) or (s, n, n). Target states for the initial states passed to <code>optimize</code>. If performing master-equation optimization, the target states should be passed as a list of density matrices.</p> </li> <li> <code>cost_multiplier</code>               (<code>float</code>, default:                   <code>1.0</code> )           \u2013            <p>Weight for this cost function relative to other cost functions.</p> </li> <li> <code>target_cost</code>               (<code>float</code>, default:                   <code>0.005</code> )           \u2013            <p>Target value for this cost function. If options.all_costs is True, the optimization terminates early if all cost functions fall below their target values. If options.all_costs is False, the optimization terminates if only one cost function falls below its target value.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>IncoherentInfidelity</code>           \u2013            <p>Callable object that returns the incoherent infidelity and whether the infidelity is below the target value.</p> </li> </ul>"},{"location":"api/#qontrol.cost.coherent_infidelity","title":"<code>coherent_infidelity(target_states: list[QArrayLike], cost_multiplier: float = 1.0, target_cost: float = 0.005) -&gt; CoherentInfidelity</code>","text":"<p>Instantiate the cost function for calculating infidelity coherently.</p> <p>This fidelity is defined as $$     F_{\\rm coherent} = |\\sum_{k}\\langle\\psi_{t}^{k}|\\psi_{i}^{k}(T)\\rangle|^2, $$ where the states at the end of the pulse are \\(|\\psi_{i}^{k}(T)\\rangle\\) and the target states are \\(|\\psi_{t}^{k}\\rangle\\).</p> <p>Parameters:</p> <ul> <li> <code>target_states</code>               (<code>list[QArrayLike]</code>)           \u2013            <p>Shape = (s, n, 1) or (s, n, n). Target states for the initial states passed to <code>optimize</code>. If performing master-equation optimization, the target states should be passed as a list of density matrices.</p> </li> <li> <code>cost_multiplier</code>               (<code>float</code>, default:                   <code>1.0</code> )           \u2013            <p>Weight for this cost function relative to other cost functions.</p> </li> <li> <code>target_cost</code>               (<code>float</code>, default:                   <code>0.005</code> )           \u2013            <p>Target value for this cost function. If options.all_costs is True, the optimization terminates early if all cost functions fall below their target values. If options.all_costs is False, the optimization terminates if only one cost function falls below its target value.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>CoherentInfidelity</code>           \u2013            <p>Callable object that returns the coherent infidelity and whether the infidelity is below the target value.</p> </li> </ul>"},{"location":"api/#qontrol.cost.propagator_infidelity","title":"<code>propagator_infidelity(target_unitary: QArrayLike, cost_multiplier: float = 1.0, target_cost: float = 0.005) -&gt; PropagatorInfidelity</code>","text":"<p>Instantiate the cost function for calculating infidelity of a propagator.</p> <p>This fidelity is defined as $$     F_{\\rm propagator} = \\Tr(U_{t}^{\\dagger} U/d)^2, $$ where the propagator at the end of the pulse is \\(U\\), the dimension of the system is \\(d\\) and the target unitary \\(U_{t}\\).</p> <p>Parameters:</p> <ul> <li> <code>target_unitary</code>               (<code>QArrayLike</code>)           \u2013            <p>Shape = (n,n). Target unitary for the initial states passed to <code>optimize</code>.</p> </li> <li> <code>cost_multiplier</code>               (<code>float</code>, default:                   <code>1.0</code> )           \u2013            <p>Weight for this cost function relative to other cost functions.</p> </li> <li> <code>target_cost</code>               (<code>float</code>, default:                   <code>0.005</code> )           \u2013            <p>Target value for this cost function. If options.all_costs is True, the optimization terminates early if all cost functions fall below their target values. If options.all_costs is False, the optimization terminates if only one cost function falls below its target value.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>PropagatorInfidelity</code>           \u2013            <p>Callable object that returns the propagator infidelity and whether the infidelity is below the target value.</p> </li> </ul>"},{"location":"api/#qontrol.cost.forbidden_states","title":"<code>forbidden_states(forbidden_states_list: list[QArrayLike], cost_multiplier: float = 1.0, target_cost: float = 0.0) -&gt; ForbiddenStates</code>","text":"<p>Instantiate the cost function for penalizing forbidden-state occupation.</p> <p>This cost function is defined as $$     C=\\sum_{k}\\sum_{f}\\int_{0}^{T}dt|\\langle\\psi_{f}^{k}|\\psi_{i}^{k}(t)\\rangle|^2, $$ where \\(|\\psi_{i}^{k}(t)\\rangle\\) is the \\(k^{\\rm th}\\) initial state propagated to time \\(t\\) and |\\psi_{f}^{k}\\rangle is a forbidden state for the \\(k^{\\rm th}\\) initial state.</p> <p>Parameters:</p> <ul> <li> <code>forbidden_states_list</code>               (<code>list[QArrayLike]</code>)           \u2013            <p>Shape of QArrays = (n, 1) or (n, n)_. A list of forbidden states for each initial state (indexed by s). The inner lists need not all be of the same shape, for instance if some initial states have more forbidden states than others. The array is eventually reshaped to have shape (s, 1, f, n, 1) or (s, 1, f, n, n) (for <code>sesolve</code> or <code>mesolve</code>, respectively) where s is the number of initial states, f is the length of the longest forbidden-state list (with zero-padding for meaningless entries) and 1 is an added batch dimension for eventually batching over tsave.</p> </li> <li> <code>cost_multiplier</code>               (<code>float</code>, default:                   <code>1.0</code> )           \u2013            <p>Weight for this cost function relative to other cost functions.</p> </li> <li> <code>target_cost</code>               (<code>float</code>, default:                   <code>0.0</code> )           \u2013            <p>Target value for this cost function. If options.all_costs is True, the optimization terminates early if all cost functions fall below their target values. If options.all_costs is False, the optimization terminates if only one cost function falls below its target value.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ForbiddenStates</code>           \u2013            <p>Callable object that returns the forbidden-state cost and whether the cost is below the target value.</p> </li> </ul>"},{"location":"api/#qontrol.cost.control_area","title":"<code>control_area(threshold: float = 0.0, cost_multiplier: float = 1.0, target_cost: float = 0.0) -&gt; ControlCostArea</code>","text":"<p>Control area cost function.</p> <p>Penalize the area under the pulse curves according to $$     C = \\sum_{j}\\int_{0}^{T}\\Omega_{j}(t)dt, $$ where the \\(\\Omega_{j}\\) are the individual controls and \\(T\\) is the pulse time.</p> <p>Parameters:</p> <ul> <li> <code>threshold</code>               (<code>float</code>, default:                   <code>0.0</code> )           \u2013            <p>Threshold to use for penalizing areas above this value in absolute magnitude.</p> </li> <li> <code>cost_multiplier</code>               (<code>float</code>, default:                   <code>1.0</code> )           \u2013            <p>Weight for this cost function relative to other cost functions.</p> </li> <li> <code>target_cost</code>               (<code>float</code>, default:                   <code>0.0</code> )           \u2013            <p>Target value for this cost function. If options.all_costs is True, the optimization terminates early if all cost functions fall below their target values. If options.all_costs is False, the optimization terminates if only one cost function falls below its target value.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ControlCostArea</code>           \u2013            <p>Callable object that returns the control-area cost and whether the cost is below the target value.</p> </li> </ul>"},{"location":"api/#qontrol.cost.control_norm","title":"<code>control_norm(threshold: float, cost_multiplier: float = 1.0, target_cost: float = 0.0) -&gt; ControlCostNorm</code>","text":"<p>Control norm cost function.</p> <p>Penalize the norm of the controls above some threshold according to $$     C = \\sum_{j}\\int_{0}^{T}ReLU(|\\Omega_{j}(t)|-\\Omega_{max})dt, $$ where the \\(\\Omega_{j}\\) are the individual controls, \\(T\\) is the pulse time and \\(\\Omega_{max}\\) is the threshold.</p> <p>Parameters:</p> <ul> <li> <code>threshold</code>               (<code>float</code>)           \u2013            <p>Threshold to use for penalizing amplitudes above this value in absolute magnitude.</p> </li> <li> <code>cost_multiplier</code>               (<code>float</code>, default:                   <code>1.0</code> )           \u2013            <p>Weight for this cost function relative to other cost functions.</p> </li> <li> <code>target_cost</code>               (<code>float</code>, default:                   <code>0.0</code> )           \u2013            <p>Target value for this cost function. If options.all_costs is True, the optimization terminates early if all cost functions fall below their target values. If options.all_costs is False, the optimization terminates if only one cost function falls below its target value.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ControlCostNorm</code>           \u2013            <p>Callable object that returns the control-norm cost and whether the cost is below the target value.</p> </li> </ul>"},{"location":"api/#qontrol.cost.custom_control_cost","title":"<code>custom_control_cost(cost_fun: callable, cost_multiplier: float = 1.0, target_cost: float = 0.0) -&gt; CustomControlCost</code>","text":"<p>Cost function based on an arbitrary transformation of the controls.</p> <p>Penalize the controls according to an arbitrary function <code>F</code> $$     C = \\sum_{j}\\int_{0}^{T}F(\\Omega_{j}(t))dt, $$</p> <p>Parameters:</p> <ul> <li> <code>cost_fun</code>               (<code>callable</code>)           \u2013            <p>Cost function which must have signature <code>(control_amp: Array) -&gt; Array</code>.</p> </li> <li> <code>cost_multiplier</code>               (<code>float</code>, default:                   <code>1.0</code> )           \u2013            <p>Weight for this cost function relative to other cost functions.</p> </li> <li> <code>target_cost</code>               (<code>float</code>, default:                   <code>0.0</code> )           \u2013            <p>Target value for this cost function. If options.all_costs is True, the optimization terminates early if all cost functions fall below their target values. If options.all_costs is False, the optimization terminates if only one cost function falls below its target value.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>CustomControlCost</code>           \u2013            <p>Callable object that returns the cost for the custom function and whether the cost is below the target value.</p> </li> </ul> Example: Penalize negative drive amplitudes <pre><code>def penalize_negative(control_amp: jax.Array) -&gt; jax.Array:\n    return jax.nn.relu(-control_amp)\n\n\nnegative_amp_cost = ql.custom_control_cost(penalize_negative)\n</code></pre>"},{"location":"api/#qontrol.cost.custom_cost","title":"<code>custom_cost(cost_fun: callable, cost_multiplier: float = 1.0, target_cost: float = 0.0) -&gt; CustomCost</code>","text":"<p>A custom cost function.</p> <p>In many (most!) cases, the user may want to add a cost function to their optimization that is not included in the hardcoded set of available cost functions.</p> <p>Parameters:</p> <ul> <li> <code>cost_fun</code>               (<code>callable</code>)           \u2013            <p>Cost function which must have signature <code>(result: dq.SolveResult, H: dq.TimeQArray, parameters: dict | Array) -&gt; Array</code>.</p> </li> <li> <code>cost_multiplier</code>               (<code>float</code>, default:                   <code>1.0</code> )           \u2013            <p>Weight for this cost function relative to other cost functions.</p> </li> <li> <code>target_cost</code>               (<code>float</code>, default:                   <code>0.0</code> )           \u2013            <p>Target value for this cost function. If options.all_costs is True, the optimization terminates early if all cost functions fall below their target values. If options.all_costs is False, the optimization terminates if only one cost function falls below its target value.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>CustomCost</code>           \u2013            <p>Callable object that returns the cost for the custom function.</p> </li> </ul> Example: Penalize an expectation value <p>Let's imagine we want to penalize the value of some expectation value at the final time in <code>tsave</code>.</p> <p><pre><code>def penalize_expect(\n    result: SolveResult, H: TimeQArray, parameters: dict | Array\n) -&gt; Array:\n    # 0 is the index of the operator, -1 is the time index\n    return jnp.sum(jnp.abs(result.expects[0, -1]))\n\n\nexpect_cost = ql.custom_cost(penalize_expect)\n</code></pre> Then <code>expect_cost</code> can be added to the other utilized cost functions. The only thing happening under the hood is that the <code>penalize_expect</code> function is passed to <code>jax.tree_util.Partial</code> to enable it to be passed through jitted functions without issue.</p>"},{"location":"api/#models","title":"Models","text":""},{"location":"api/#qontrol.model.sesolve_model","title":"<code>sesolve_model(H_function: callable, psi0: QArrayLike, tsave_or_function: ArrayLike | callable, *, exp_ops: list[ArrayLike] | None = None) -&gt; SESolveModel</code>","text":"<p>Instantiate sesolve model.</p> <p>Here we instantiate the model that is called at each step of the optimization iteration, returning a tuple of the result of calling <code>sesolve</code> as well as the Hamiltonian evaluated at the parameter values.</p> <p>Parameters:</p> <ul> <li> <code>H_function</code>               (<code>callable</code>)           \u2013            <p>function specifying how to update the Hamiltonian</p> </li> <li> <code>psi0</code>               (<code>QArrayLike</code>)           \u2013            <p>Shape = (..., n, 1). Initial states.</p> </li> <li> <code>tsave_or_function</code>               (<code>ArrayLike | callable</code>)           \u2013            <p>If ArrayLike, then Shape = (ntsave,). Either an array of times passed to <code>sesolve</code> or a method specifying how to update the times that are passed to <code>sesolve</code>.</p> </li> <li> <code>exp_ops</code>               (<code>list[ArrayLike] | None</code>, default:                   <code>None</code> )           \u2013            <p>Operators to calculate expectation values of, in case some of the cost functions depend on the value of certain expectation values.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>SESolveModel</code>           \u2013            <p>Model that when called with the parameters we optimize over as argument returns the results of <code>sesolve</code> as well as the updated Hamiltonian.</p> </li> </ul> Piecewise-constant control <p><pre><code>tsave = jnp.linspace(0.0, 11.0, 10)\npsi0 = [dq.basis(2, 0)]\nH1s = [dq.sigmax(), dq.sigmay()]\n\n\ndef H_pwc(values: Array) -&gt; dq.TimeQArray:\n    H = dq.sigmaz()\n    for idx, _H1 in enumerate(H1s):\n        H += dq.pwc(tsave, values[idx], _H1)\n    return H\n\n\nsesolve_model = ql.sesolve_model(H_pwc, psi0, tsave)\n</code></pre> See for example this tutorial.</p> Spline control <p>In more complex cases, we can imagine that the optimized parameters are the control points fed into a spline, and additionally the control times themselves are optimized. <pre><code>init_drive_params_topt = {\n    'dp': -0.001 * jnp.ones((len(H1s), len(tsave))),\n    't': tsave[-1],\n}\n\n\ndef H_func_topt(t: float, drive_params_dict: dict) -&gt; dq.TimeQArray:\n    drive_params = drive_params_dict['dp']\n    new_tsave = jnp.linspace(0.0, drive_params_dict['t'], len(tsave))\n    drive_spline = _drive_spline(drive_params, envelope, new_tsave)\n    drive_amps = drive_spline.evaluate(t)\n    drive_Hs = jnp.einsum('d,dij-&gt;ij', drive_amps, H1s)\n    return H0 + drive_Hs\n\n\ndef update_H_topt(drive_params_dict: dict) -&gt; dq.TimeQArray:\n    new_H = jtu.Partial(H_func_topt, drive_params_dict=drive_params_dict)\n    return dq.timecallable(new_H)\n\n\ndef update_tsave_topt(drive_params_dict: dict) -&gt; jax.Array:\n    return jnp.linspace(0.0, drive_params_dict['t'], len(tsave))\n\n\nse_t_opt_Kerr_model = ql.sesolve_model(update_H_topt, psi0, update_tsave_topt)\n</code></pre> See for example this tutorial.</p>"},{"location":"api/#qontrol.model.mesolve_model","title":"<code>mesolve_model(H_function: callable, jump_ops: list[QArrayLike | TimeQArray], rho0: QArrayLike, tsave_or_function: ArrayLike | callable, *, exp_ops: list[ArrayLike] | None = None) -&gt; MESolveModel</code>","text":"<p>Instantiate mesolve model.</p> <p>Here we instantiate the model called at each step of the optimization iteration, returning a tuple of the result of calling <code>mesolve</code> as well as the Hamiltonian evaluated at the parameter values.</p> <p>Parameters:</p> <ul> <li> <code>H_function</code>               (<code>callable</code>)           \u2013            <p>function specifying how to update the Hamiltonian</p> </li> <li> <code>jump_ops</code>               (<code>list[QArrayLike | TimeQArray]</code>)           \u2013            <p>Each of QArray or TimeQArray is has shape = (...Lk, n, n)). List of jump operators.</p> </li> <li> <code>rho0</code>               (<code>QArrayLike</code>)           \u2013            <p>Shape = (..., n, n). Initial density matrices.</p> </li> <li> <code>tsave_or_function</code>               (<code>ArrayLike | callable</code>)           \u2013            <p>If ArrayLike, then Shape = (ntsave,). Either an array of times passed to sesolve or a method specifying how to update the times that are passed to <code>mesolve</code>.</p> </li> <li> <code>exp_ops</code>               (<code>list[ArrayLike] | None</code>, default:                   <code>None</code> )           \u2013            <p>Operators to calculate expectation values of, in case some of the cost functions depend on the value of certain expectation values.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>MESolveModel</code>           \u2013            <p>Model that when called with the parameters we optimize over as argument returns the results of <code>mesolve</code> as well as the updated Hamiltonian.</p> </li> </ul> Instantiating a MESolveModel <p>Instantiating a <code>MESolveModel</code> is quite similar to instantiating an <code>SESolveModel</code>, with the two differences being that we need to supply jump operators, and the initial and target states should be specified as density matrices. Continuing the last example from <code>sesolve_model</code> <pre><code>jump_ops = [0.03 * dq.sigmax()]\nme_initial_states = dq.todm(psi0)\nme_Kerr_model = ql.mesolve_model(\n    update_H_topt, jump_ops, me_initial_states, update_tsave_topt\n)\n</code></pre> See this tutorial for example</p>"},{"location":"api/#qontrol.model.sepropagator_model","title":"<code>sepropagator_model(H_function: callable, tsave_or_function: ArrayLike | callable) -&gt; SEPropagatorModel</code>","text":"<p>Instantiate sepropagator model.</p> <p>Here we instantiate the model that is called at each step of the optimization iteration, returning a tuple of the result of calling <code>sepropagator</code> as well as the Hamiltonian evaluated at the parameter values.</p> <p>Parameters:</p> <ul> <li> <code>H_function</code>               (<code>callable</code>)           \u2013            <p>function specifying how to update the Hamiltonian</p> </li> <li> <code>tsave_or_function</code>               (<code>ArrayLike | callable</code>)           \u2013            <p>If ArrayLike, then Shape = (ntsave,). Either an array of times passed to <code>sepropagator</code> or a method specifying how to update the times that are passed to <code>sepropagator</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>SEPropagatorModel</code>           \u2013            <p>Model that when called with the parameters we optimize over as argument returns the results of <code>sepropagator</code> as well as the updated Hamiltonian.</p> </li> </ul> Instantiating a <code>SEPropagatorModel</code> <pre><code>tsave = jnp.linspace(0.0, 11.0, 10)\nH1s = [dq.sigmax(), dq.sigmay()]\n\n\ndef H_pwc(values: Array) -&gt; dq.TimeQArray:\n    H = dq.sigmaz()\n    for idx, _H1 in enumerate(H1s):\n        H += dq.pwc(tsave, values[idx], _H1)\n    return H\n\n\nsepropagator_model = ql.sepropagator_model(H_pwc, tsave)\n</code></pre>"},{"location":"api/#qontrol.model.mepropagator_model","title":"<code>mepropagator_model(H_function: callable, jump_ops: list[QArrayLike | TimeQArray], tsave_or_function: ArrayLike | callable) -&gt; MEPropagatorModel</code>","text":"<p>Instantiate mepropagator model.</p> <p>Here we instantiate the model that is called at each step of the optimization iteration, returning a tuple of the result of calling <code>mepropagator</code> as well as the Hamiltonian evaluated at the parameter values.</p> <p>Parameters:</p> <ul> <li> <code>H_function</code>               (<code>callable</code>)           \u2013            <p>function specifying how to update the Hamiltonian</p> </li> <li> <code>jump_ops</code>               (<code>list[QArrayLike | TimeQArray]</code>)           \u2013            <p>Each of QArray or TimeQArray is has shape = (...Lk, n, n)). List of jump operators.</p> </li> <li> <code>tsave_or_function</code>               (<code>ArrayLike | callable</code>)           \u2013            <p>If ArrayLike, then Shape = (ntsave,). Either an array of times passed to <code>mepropagator</code> or a method specifying how to update the times that are passed to <code>mepropagator</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>MEPropagatorModel</code>           \u2013            <p>Model that when called with the parameters we optimize over as argument returns the results of <code>mepropagator</code> as well as the updated Hamiltonian.</p> </li> </ul> Instantiating a <code>MEPropagatorModel</code> <p>Instantiating a <code>MEPropagatorModel</code> is quite similar to instantiating an <code>SEPropagatorModel</code>, with the difference being that we need to supply jump operators. Continuing the last example from <code>sepropagator_model</code> <pre><code>jump_ops = [0.03 * dq.sigmax()]\nmep_Kerr_model = ql.mepropagator_model(\n    update_H_topt, jump_ops, update_tsave_topt\n)\n</code></pre></p>"},{"location":"api/#custom-plotting","title":"Custom Plotting","text":""},{"location":"api/#qontrol.plot.plot_costs","title":"<code>plot_costs(ax: Axes, costs: Cost, epoch: int, cost_values_over_epochs: list) -&gt; Axes</code>","text":"<p>Plot the evolution of the cost function values.</p>"},{"location":"api/#qontrol.plot.get_controls","title":"<code>get_controls(H: TimeQArray, tsave: np.ndarray) -&gt; list[np.ndarray]</code>","text":"<p>Extract the Hamiltonian prefactors at the supplied times.</p>"},{"location":"api/#qontrol.plot.plot_controls","title":"<code>plot_controls(ax: Axes, _expects: Array | None, model: Model, parameters: Array | dict) -&gt; Axes</code>","text":"<p>Plot the Hamiltonian prefactors, usually corresponding to controls.</p>"},{"location":"api/#qontrol.plot.plot_fft","title":"<code>plot_fft(ax: Axes, _expects: Array | None, model: Model, parameters: Array | dict) -&gt; Axes</code>","text":"<p>Plot the fft of the Hamiltonian controls.</p>"},{"location":"api/#qontrol.plot.plot_expects","title":"<code>plot_expects(ax: Axes, expects: Array | None, model: Model, parameters: Array | dict) -&gt; Axes</code>","text":"<p>Plot the expectation values obtained from the time evolution.</p>"},{"location":"api/#qontrol.plot.custom_plotter","title":"<code>custom_plotter(plotting_functions: list[Callable]) -&gt; Plotter</code>","text":"<p>Instantiate a custom Plotter for tracking results during optimization.</p> <p>This function returns a Plotter that can be passed to <code>optimize</code> to track the progress of an optimization run. Note that the cost function values are always plotted in the first panel and that there is no limit to the number of plots a user can ask for: if more than four, additional plots will appear in a new row of four, and so on.</p> <p>Parameters:</p> <ul> <li> <code>plotting_functions</code>               (<code>list[Callable]</code>)           \u2013            <p>list of functions that each return a plot useful for tracking intermediate results, such as the value of the optimized controls, fft of the controls, expectation values, etc. Each function must have signature <code>example_plot_function(ax, expects, model, parameters)</code> where <code>ax</code> is the <code>matplotlib.pyplot.Axes</code> instance where the results are plotted, <code>expects</code> is of type dq.SolveResult.expects (which could be <code>None</code>), <code>model</code> is of type <code>ql.Model</code> and <code>parameters</code> are the parameters being optimized. Of course, some of these arguments may be unused for a particular plot (for instance if we are plotting expectation values, we don't need access to <code>parameters</code>).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Plotter</code>           \u2013            <p>Plotter whose <code>update_plots</code> method is repeatedly called during an optimization</p> </li> <li> <code>Plotter</code>           \u2013            <p>run.</p> </li> </ul> Example <p>We plot the controls as well as the expectation values for two different initial states <pre><code>import dynamiqs as dq\nimport jax.numpy as jnp\nimport numpy as np\nimport qontrol as ql\nfrom functools import partial\n\nH1s = [dq.sigmax(), dq.sigmay()]\nH1_labels = ['X', 'Y']\n\n\ndef plot_states(\n    ax: Axes,\n    expects: Array | None,\n    model: ql.Model,\n    parameters: Array | dict,\n    which=0,\n) -&gt; Axes:\n    ax.set_facecolor('none')\n    tsave = model.tsave_function(parameters)\n    batch_idxs = np.ndindex(*expects.shape[:-3])\n    for batch_idx in batch_idxs:\n        ax.plot(tsave, np.real(expects[tuple(batch_idx), which, 0]))\n    ax.set_xlabel('time [ns]')\n    ax.set_ylabel(\n        f'population in $|1\\\\rangle$ for initial state $|{which}\\\\rangle$'\n    )\n    return ax\n\n\ndef plot_controls(\n    ax: Axes, _expects: Array | None, model: ql.Model, parameters: Array | dict\n) -&gt; Axes:\n    ax.set_facecolor('none')\n    tsave = model.tsave_function(parameters)\n    finer_tsave = jnp.linspace(0.0, tsave[-1], 10 * len(tsave))\n    for idx, control in enumerate(parameters):\n        H_c = dq.pwc(tsave, control, H1s[idx])\n        ax.plot(\n            finer_tsave,\n            np.real(jax.vmap(H_c.prefactor)(finer_tsave)) / 2 / np.pi,\n            label=H1_labels[idx],\n        )\n    ax.legend(loc='lower right', framealpha=0.0)\n    ax.set_ylabel('pulse amplitude [GHz]')\n    ax.set_xlabel('time [ns]')\n    return ax\n\n\nplotter = ql.custom_plotter(\n    [\n        plot_controls,\n        partial(plot_states, which=0),\n        partial(plot_states, which=1),\n    ]\n)\n</code></pre> See for example this tutorial.</p>"},{"location":"api/#file-utilities","title":"File utilities","text":""},{"location":"contributing/","title":"Contributing to <code>qontrol</code>","text":"<p>We welcome your contribution, whether it be additional cost functions, new functionality, better documentation, etc.</p>"},{"location":"contributing/#requirements","title":"Requirements","text":"<p>The project was written using Python 3.10+, you must have a compatible version of Python (i.e. &gt;= 3.10) installed on your computer.</p>"},{"location":"contributing/#setup","title":"Setup","text":"<p>Clone the repository:</p> <pre><code>git clone https://github.com/dkweiss31/qontrol.git\ncd qontrol\n</code></pre> <p>It is good practice to use a virtual environment to install the dependencies, such as conda. Once this environment has been activated, you can run </p> <pre><code>pip install -e .\n</code></pre> <p>to install the package and its dependencies. As a developer you also need to install the developer dependencies:</p> <pre><code>pip install -e \".[dev]\"\n</code></pre>"},{"location":"contributing/#code-style","title":"Code style","text":"<p>This project follows PEP8 and uses automatic formatting and linting tools to ensure that the code is compliant.</p>"},{"location":"contributing/#workflow","title":"Workflow","text":""},{"location":"contributing/#before-submitting-a-pull-request-run-all-tasks","title":"Before submitting a pull request (run all tasks)","text":"<p>Run all tasks before each commit:</p> <pre><code>task all\n</code></pre>"},{"location":"contributing/#build-the-documentation","title":"Build the documentation","text":"<p>The documentation is built using MkDocs and the Material for MkDocs theme. MkDocs generates a static website based on the markdown files in the <code>docs/</code> directory.</p> <p>To preview the changes to the documentation as you edit the docstrings or the markdown files in <code>docs/</code>, we recommend starting a live preview server, which will automatically rebuild the website upon modifications:</p> <pre><code>task docserve\n</code></pre> <p>Open http://localhost:8000/ in your web browser to preview the documentation website.</p> <p>You can build the static documentation website locally with:</p> <pre><code>task docbuild\n</code></pre> <p>This will create a <code>site/</code> directory with the contents of the documentation website. You can then simply open <code>site/index.html</code> in your web browser to view the documentation website.</p>"},{"location":"contributing/#run-specific-tasks","title":"Run specific tasks","text":"<p>You can also execute tasks individually:</p> <pre><code>&gt; task --list\nlint         lint the code (ruff)\nformat       auto-format the code (ruff)\ncodespell    check for misspellings (codespell)\nclean        clean the code (ruff + codespell)\ntest         run the unit tests suite (pytest)\ndocbuild     build the documentation website\ndocserve     preview documentation website with hot-reloading\nall          run all tasks before a commit (ruff + codespell + pytest)\nci           run all the CI checks\n</code></pre>"},{"location":"examples/Kerr_oscillator/","title":"Kerr Oscillator","text":"<pre><code>import diffrax as dx\nimport dynamiqs as dq\nimport jax.numpy as jnp\nimport optax\nfrom jax import Array\n\nimport qontrol as ql\n</code></pre> <pre><code>time = 20.0\ncontrol_dt = 2.0\nramp_nts = 4\nntimes = int(time // control_dt) + 1\ntsave = jnp.linspace(0, time, ntimes)\noptimizer = optax.adam(learning_rate=0.001, b1=0.999, b2=0.999)\nopt_options = {'verbose': False, 'epochs': 4000, 'plot': True, 'plot_period': 40}\ndq_options = dq.Options(save_states=True, progress_meter=None)\n</code></pre> <p>We define our Kerr oscillator to have a 100 MHz Kerr. We optimize the drive envelopes on the I and Q quadratures.</p> <pre><code>dim = 5\nKerr = -2.0 * jnp.pi * 0.100\na = dq.destroy(dim)\nH0 = 0.5 * Kerr * dq.dag(a) @ dq.dag(a) @ a @ a\nH1s = [a + dq.dag(a), 1j * (a - dq.dag(a))]\nH1_labels = ['I', 'Q']\n</code></pre> <p>Here we attempt to perform an <code>X</code> gate, and penalize population leaking to the higher-lying states</p> <pre><code>initial_states = [dq.basis(dim, 0), dq.basis(dim, 1)]\nfinal_states = [dq.basis(dim, 1), dq.basis(dim, 0)]\n_forbidden_states = [dq.basis(dim, idx) for idx in range(2, dim)]\nforbidden_states_list = len(initial_states) * [_forbidden_states]\n</code></pre> <p>We initialize the guess for the controls and moreover define an envelope of cosine ramps with a flat top to ensure that the control turns on slowly.</p> <pre><code>init_drive_params = {'dp': -0.001 * jnp.ones((len(H1s), ntimes))}\n\ncos_ramp = (1 - jnp.cos(jnp.linspace(0.0, jnp.pi, ramp_nts))) / 2\nenvelope = jnp.concatenate(\n    (cos_ramp, jnp.ones(ntimes - 2 * ramp_nts), jnp.flip(cos_ramp))\n)\n\n\ndef _drive_spline(\n    drive_params: Array, envelope: Array, ts: Array\n) -&gt; dx.CubicInterpolation:\n    drive_w_envelope = jnp.einsum('t,...t-&gt;t...', envelope, drive_params)\n    drive_coeffs = dx.backward_hermite_coefficients(ts, drive_w_envelope)\n    return dx.CubicInterpolation(ts, drive_coeffs)\n\n\ndef H_func(drive_params_dict: dict) -&gt; dq.TimeQArray:\n    drive_params = drive_params_dict['dp']\n    H = dq.constant(H0)\n    H += dq.modulated(_drive_spline(drive_params[0], envelope, tsave).evaluate, H1s[0])\n    H += dq.modulated(_drive_spline(drive_params[1], envelope, tsave).evaluate, H1s[1])\n    return H\n\n\nexp_ops = [dq.basis(dim, idx) @ dq.dag(dq.basis(dim, idx)) for idx in range(dim)]\n\nse_Kerr_model = ql.sesolve_model(H_func, initial_states, tsave, exp_ops=exp_ops)\n</code></pre> <pre><code>costs = ql.coherent_infidelity(target_states=final_states, target_cost=0.005)\ncosts += 0.1 * ql.forbidden_states(\n    forbidden_states_list=forbidden_states_list, target_cost=0.4\n)\n</code></pre> <pre><code>opt_params = ql.optimize(\n    init_drive_params,\n    costs,\n    model=se_Kerr_model,\n    optimizer=optimizer,\n    opt_options=opt_options,\n    dq_options=dq_options,\n)\n</code></pre> <pre>\n<code>target cost reached for all cost functions;\noptimization terminated after 126 epochs; \naverage epoch time (excluding jit) of 0.00106 s; \nmax epoch time of 0.004 s; \nmin epoch time of 0.001 s\n</code>\n</pre> <p>Try playing with the <code>cost_multiplier</code> of the forbidden states cost function to see how it modifies the pulse! Specifically, try setting it to 0 so that the optimizer is happy to populate the 2nd excited state without penalty.</p> <pre><code>jump_ops = [0.01 * a]\nme_initial_states = dq.todm(initial_states)\nme_final_states = dq.todm(final_states)\nme_forbidden_states_list = len(initial_states) * [dq.todm(_forbidden_states)]\nme_costs = ql.coherent_infidelity(target_states=me_final_states, target_cost=0.005)\nme_costs += 0.1 * ql.forbidden_states(\n    forbidden_states_list=me_forbidden_states_list, target_cost=0.4\n)\n\nme_Kerr_model = ql.mesolve_model(\n    H_func, jump_ops, me_initial_states, tsave, exp_ops=exp_ops\n)\n</code></pre> <pre><code>opt_params_me = ql.optimize(\n    init_drive_params,\n    me_costs,\n    me_Kerr_model,\n    optimizer=optimizer,\n    opt_options=opt_options,\n    dq_options=dq_options,\n)\n</code></pre> <pre>\n<code>target cost reached for all cost functions;\noptimization terminated after 395 epochs; \naverage epoch time (excluding jit) of 0.00115 s; \nmax epoch time of 0.002 s; \nmin epoch time of 0.001 s\n</code>\n</pre>"},{"location":"examples/Kerr_oscillator/#optimization-for-a-kerr-oscillator","title":"Optimization for a Kerr oscillator","text":"<p>In this example we will try to implement DRAG-like pulses on a Kerr oscillator, penalizing population going to leakage states. We will additionally use a slightly more complicated control scheme than in the qubit example. There we performed traditional grape, with piecewise-constant controls. Here we fit a spline to control knot points: it is these knot points that are optimized.</p> <p>This technique has the benefit of ensuring smooth controls if the control points are spread far enough apart in time, which is not guaranteed in the case of piece-wise constant controls. It is important to emphasize here that the control points are in no way related to the points chosen by the numerical integrator for solving the differential equation! This is a significant difference from typical QOC/GRAPE implementations that perform numerical integration of the Schr\u00f6dinger equation by calculating step propagators with sufficiently small time steps.</p> <p>This example is available as a Jupyter notebook here.</p>"},{"location":"examples/Kerr_oscillator/#master-equation-optimization","title":"Master-equation optimization","text":"<p>We can also instead perform the optimization directly on the master equation. Continuing the above example, we need now to initialize an <code>mesolve_model</code>, which calls <code>dq.mesolve</code>, and to correctly specify the initial and target states as density matrices.</p>"},{"location":"examples/qubit/","title":"Qubit","text":"<pre><code>from functools import partial\n\nimport dynamiqs as dq\nimport jax\nimport jax.numpy as jnp\nimport numpy as np\nimport optax\nfrom jax import Array\nfrom jax.random import normal, PRNGKey\nfrom matplotlib.pyplot import Axes\n\nimport qontrol as ql\n</code></pre> <pre><code>time = 30\ncontrol_dt = 2.0\nntimes = int(time // control_dt) + 1\noptimizer = optax.adam(learning_rate=0.001, b1=0.99, b2=0.99)\ntsave = jnp.linspace(0, time, ntimes)\nopt_options = {'verbose': False, 'epochs': 4000, 'plot': True, 'plot_period': 200}\ndq_options = dq.Options(save_states=False, progress_meter=None)\n</code></pre> <p>Here we initialize the random qubit frequency fluctuations pulled from a normal distribution. Note that the drive is on resonance with the average value of the qubit frequency.</p> <pre><code>key = PRNGKey(42)\nn_batch = 21\nrandom_freqs = 2.0 * jnp.pi * normal(key, shape=(n_batch,)) / 500\nH0 = random_freqs[:, None, None] * dq.sigmaz()\nH1s = [dq.sigmax(), dq.sigmay()]\nH1_labels = ['X', 'Y']\n</code></pre> <p>Here we define what final states the initial states should map to. In this case we want to achieve a Y gate</p> <pre><code>initial_states = [dq.basis(2, 0), dq.basis(2, 1)]\ntarget_states = [-1j * dq.basis(2, 1), 1j * dq.basis(2, 0)]\n</code></pre> <p>We next initialize our first guess for the controls and define the function that, given the controls, returns the Hamiltonian.</p> <pre><code>init_drive_params = -0.001 * jnp.ones((len(H1s), ntimes - 1))\n\n\ndef H_pwc(values: Array) -&gt; dq.TimeQArray:\n    H = dq.constant(H0)\n    for idx, _H1 in enumerate(H1s):\n        H += dq.pwc(tsave, values[idx], _H1)\n    return H\n\n\nexp_ops = [dq.basis(2, 1) @ dq.dag(dq.basis(2, 1))]\nsesolve_model = ql.sesolve_model(H_pwc, initial_states, tsave, exp_ops=exp_ops)\n</code></pre> <p>In this example we use the coherent definition of the infidelity and penalize drive strengths above 16 MHz</p> <pre><code>costs = ql.coherent_infidelity(target_states=target_states, target_cost=0.001)\ncosts += ql.control_norm(2.0 * jnp.pi * 0.016, target_cost=0.1)\n</code></pre> <p>We modify the default plotter to track both the ground and first excited states individually</p> <pre><code>def plot_states(\n    ax: Axes,\n    expects: Array | None,\n    model: ql.Model,\n    parameters: Array | dict,\n    which: int = 0,\n) -&gt; Axes:\n    ax.set_facecolor('none')\n    _tsave = model.tsave_function(parameters)\n    for batch_idx in range(n_batch):\n        ax.plot(_tsave, np.real(expects[batch_idx, which, 0]))\n    ax.set_xlabel('time [ns]')\n    ax.set_ylabel(f'population in $|1\\\\rangle$ for initial state $|{which}\\\\rangle$')\n    return ax\n\n\ndef plot_controls(\n    ax: Axes, _expects: Array | None, model: ql.Model, parameters: Array | dict\n) -&gt; Axes:\n    ax.set_facecolor('none')\n    _tsave = model.tsave_function(parameters)\n    finer_tsave = jnp.linspace(0.0, _tsave[-1], 10 * len(_tsave))\n    for idx, control in enumerate(parameters):\n        H_c = dq.pwc(_tsave, control, H1s[idx])\n        ax.plot(\n            finer_tsave,\n            np.real(jax.vmap(H_c.prefactor)(finer_tsave)) / 2 / np.pi,\n            label=H1_labels[idx],\n        )\n    ax.legend(loc='lower right', framealpha=0.0)\n    ax.set_ylabel('pulse amplitude [GHz]')\n    ax.set_xlabel('time [ns]')\n    return ax\n\n\nplotter = ql.custom_plotter(\n    [plot_controls, partial(plot_states, which=0), partial(plot_states, which=1)]\n)\n</code></pre> <pre><code>opt_params = ql.optimize(\n    init_drive_params,\n    costs,\n    sesolve_model,\n    plotter=plotter,\n    optimizer=optimizer,\n    opt_options=opt_options,\n    dq_options=dq_options,\n)\n</code></pre> <pre>\n<code>target cost reached for all cost functions;\noptimization terminated after 1688 epochs; \naverage epoch time (excluding jit) of 0.00103 s; \nmax epoch time of 0.01 s; \nmin epoch time of 0.001 s\n</code>\n</pre> <p>We see that despite the MHz-level frequency variations of the qubit frequency, the obtained pulse succesfully performs the desired state transfer! Here we plot the population in the \\(|1\\rangle\\) state when beginning in the \\(|0\\rangle\\) state for the different batch instances</p>"},{"location":"examples/qubit/#grape-on-a-qubit-with-an-uncertain-frequency","title":"GRAPE on a qubit with an uncertain frequency","text":"<p>Lets start with the example of GRAPE on a qubit, optimizing the drive envelope to be robust to variations in qubit frequency. This example will illustrate the utility of batching, allowing us to average over many different qubit frequencies to obtain a pulse that achieves a high-fidelity gate and is robust to frequency fluctuations.</p> <p>This example is available as a Jupyter notebook here.</p>"}]}